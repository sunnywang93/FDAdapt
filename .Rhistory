# grid_tibble = holder_estim
m <- purrr::map_dbl(curves, ~length(.x$t)) |> mean()
interp_grid <- c(0, params$t, 1)
var_interp <- as.matrix(params[, c("H", "L", "sigma", "mu0")])
interp_mat <- apply(var_interp, MARGIN = 2,
function(x) pracma::interp1(x = interp_grid,
y = c(x[1], x, x[nrow(var_interp)]),
xi = grid_smooth))
grid_tibble <- tibble::as_tibble(cbind(t = grid_smooth, interp_mat))
bandwidth_list <- estimate_bandwidth_covariance_norm(curves,
grid_bandwidth,
grid_smooth,
k0,
grid_tibble)
}
library(funeigen)
library(funeigen)
source("/Users/swang/Dropbox/FPCA/simuls/nice_dgp/dgp.R")
#source("/Users/swang/Dropbox/Mac/Downloads/juin15/codes_val/dgp_old.R")
# source("/Users/swang/Dropbox/funeigen/R/H_and_L_functions.R")
# source("/Users/swang/Dropbox/funeigen/R/mean_optimised.R")
# source("/Users/swang/Dropbox/funeigen/R/cov_optimised.R")
# source("/Users/swang/Dropbox/funeigen/R/utils.R")
# source("/Users/swang/Dropbox/funeigen/R/eigenvalues.R")
library(funeigen)
library(foreach)
library(fs)
library(doParallel)
library(functional)
library(purrr)
#parameters
N <- 200
M <- 25
#H <- c(0.5, 0.8)
sigma <- 0.5
L <- 1
mu0 <- 1
grid_size_true <- 101
grid_true <- seq(0, 1, length.out = grid_size_true)
grid_mu <- seq(0, 1, length.out = 1001)
grid_smooth <- seq(0, 1, length.out = 101)
grid_bandwidth <- lseq(0.001, 0.1, length.out = 51)
grid_param = seq(0.1, 0.9, length.out = 20)
k0 <- 1
n_simu <- 45
tau <- 2.5 #variance of random starting points
nvalues <- 10
nfunctions <- 10
points_dist <- Curry(runif, min = 0, max = 1) #distribution of Ti
#learn true quantities from dataset powerconsumption ===========================
library(simulater)
library(fda)
df <- powerconsumption
df_list <- list()
for (idx in 1:nrow(df)) {
df_list[[idx]] <- list(
't' = seq(0, 1, length.out = 1440),
'x' = unname(unlist(as.vector(df[idx,])))
)
}
n_basis <- 9  #other tested setups 7
t0_list <- seq(.1, .9, l = 40)
grid <- seq(.1, .9, l = 101)
#df_smooth <- presmoothing(df_list, t0_list = t0_list, estimate_sigma(df_list))
df_smooth <- funestim::presmoothing(df_list, t0_list)
H0 <- funestim::estimate_H0(df_smooth)
L0 <- funestim::estimate_L0(df_smooth, H0, M)
true_tibble = tibble::tibble(t = t0_list, H = H0, L = L0, sigma = sigma,
mu0 = mu0)
basis <- create.fourier.basis(rangeval = c(min(t0_list), max(t0_list)),
nbasis = n_basis)
H0_smooth <- smooth.basis(argvals = t0_list, y = H0, fdParobj = basis)
L0_smooth <- smooth.basis(argvals = t0_list, y = L0, fdParobj = basis)
H0_eval <- eval.fd(evalarg = grid, fdobj = as.fd(H0_smooth))[, 1]
L0_eval <- eval.fd(evalarg = grid, fdobj = as.fd(L0_smooth))[, 1]
hurst_fun <- approxfun(
x = grid, y = H0_eval,
yleft = H0_eval[1], yright = H0_eval[length(H0_eval)]
)
constant_fun <- approxfun(
x = grid, y = L0_eval,
yleft = L0_eval[1], yright = L0_eval[length(L0_eval)]
)
grid_large <- seq(0, 1, l = 10001)
A_hat_prime <- constant_fun(grid_large)**(1 / hurst_fun(grid_large))
A_hat <- pracma::cumtrapz(x = grid_large, y = A_hat_prime)
A_fun <- approxfun(
x = grid_large, y = A_hat,
yleft = A_hat[1], yright = A_hat[length(A_hat)]
)
s <- exp(-3)  # Regularity for the estimation of the mean
##other tested setups 3
hurst_fun <- approxfun(
x = grid, y = H0_eval,
yleft = H0_eval[1], yright = H0_eval[length(H0_eval)]
)
#true mean
mu_model <- learn_mean(df, k = 50)
mu <- predict_mean(grid_mu, mu_model, lambda = s, k = 50) - 240
mu_t <- tibble::tibble(t = grid_mu, mu)
#tested discretisation error on grid of 1001 points - very small
grid_cov <- seq(0, 1, length.out = 101)
pp_disto <- A_fun(grid_cov)
cov_true <- tau**2 + covariance_mfbm(grid_cov, hurst_fun, pp_disto)
#obtain the "numerically true" eigenvalues from the true covariance
evalues_true <- eigen(cov_true, symmetric = TRUE,
only.values = TRUE)$values[1:nvalues] / length(grid_cov)
efunctions_true <- eigen(cov_true, symmetric = TRUE)$vectors[, 1:nvalues] *
sqrt(length(grid_cov))
#------------------------
#================================================================================
intermediate_directory <- './intermediate'
if (!dir.exists(intermediate_directory)){
dir.create(intermediate_directory)
}
n_simu = 5
cl <- parallel::makeCluster(9)
doParallel::registerDoParallel(cl)
tictoc::tic()
clusterExport(cl, as.vector(lsf.str())) # Register the functions and constant to // framework
test = foreach::foreach(i = 1:n_simu,
.packages = c("dplyr", "MASS",
"purrr", "functional", "funeigen"),
.export=c("grid_bandwidth","grid_smooth", "k0", "nvalues", "sigma")) %dopar%
{
each_filename <- paste0('RESULT_N', N, '_M', M, '_', as.character(i),
'.rda')
each_filepath <- file.path(intermediate_directory, each_filename)
if (file.exists(each_filepath)) {
next
}
points_list <- generates_points(N = N, m = M)
pfbm <- generate_curves(points_list, hurst_fun,
distortion_model = A_fun,
add_regular_grid_of_size = grid_size_true,
sigma = sigma,
tau = tau,
L = L)
pfbm_curves <- lapply(pfbm$curves,
function(x) list(t = x$observed$t, x = x$observed$x,
grid_true = x$ideal$t,
x_true = x$ideal$x))
pfbm_mu <- lapply(pfbm_curves, function(curve) {
idx <- purrr::map_dbl(curve$t, ~which.min(abs(.x - mu_t$t)))
list(
t = curve$t,
x = curve$x + mu_t$mu[idx])
})
holder_estim <- estimate_holder_quantities(pfbm_mu, grid_param)
# cov_gkp <- covariance_ll(pfbm_mu, grid_bandwidth, grid_smooth, k0,
#                          holder_estim)
# elements_gkp <- funeigen:::normalise_eigen(cov_gkp$cov, nvalues = nvalues)
# evalues_gkp <- elements_gkp$values
# efunctions_gkp <- elements_gkp$vectors
# evalues_pw <- evalues_adaptive(pfbm_mu, grid_bandwidth, grid_smooth,
#                                k0, nvalues, holder_estim)
curves =  pfbm_mu
params = holder_estim
# smooth_curves <- smooth_curves_evalues(curves, grid_bandwidth,
#                                        grid_smooth, k0, nvalues, params)
# bw_vector <- estimate_bandwidth_evalues(curves, grid_bandwidth,
#                                         grid_smooth, k0,
#                                         nvalues, params)
# cov_gkp2 <- covariance_norm(curves, grid_bandwidth, grid_smooth,
#                            k0, params)
# grid_tibble = holder_estim
m <- purrr::map_dbl(curves, ~length(.x$t)) |> mean()
interp_grid <- c(0, params$t, 1)
var_interp <- as.matrix(params[, c("H", "L", "sigma", "mu0")])
interp_mat <- apply(var_interp, MARGIN = 2,
function(x) pracma::interp1(x = interp_grid,
y = c(x[1], x, x[nrow(var_interp)]),
xi = grid_smooth))
grid_tibble <- tibble::as_tibble(cbind(t = grid_smooth, interp_mat))
bandwidth_list <- estimate_bandwidth_covariance_norm(curves,
grid_bandwidth,
grid_smooth,
k0,
grid_tibble)
}
setTxtProgressBar
#------------------------
source("/Users/swang/Dropbox/FPCA/simuls/nice_dgp/dgp.R")
#source("/Users/swang/Dropbox/Mac/Downloads/juin15/codes_val/dgp_old.R")
# source("/Users/swang/Dropbox/funeigen/R/H_and_L_functions.R")
# source("/Users/swang/Dropbox/funeigen/R/mean_optimised.R")
# source("/Users/swang/Dropbox/funeigen/R/cov_optimised.R")
# source("/Users/swang/Dropbox/funeigen/R/utils.R")
# source("/Users/swang/Dropbox/funeigen/R/eigenvalues.R")
library(funeigen)
library(foreach)
library(fs)
library(doParallel)
library(functional)
library(purrr)
#parameters
N <- 200
M <- 25
#H <- c(0.5, 0.8)
sigma <- 0.5
L <- 1
mu0 <- 1
grid_size_true <- 101
grid_true <- seq(0, 1, length.out = grid_size_true)
grid_mu <- seq(0, 1, length.out = 1001)
grid_smooth <- seq(0, 1, length.out = 101)
grid_bandwidth <- lseq(0.001, 0.1, length.out = 51)
grid_param = seq(0.1, 0.9, length.out = 20)
k0 <- 1
n_simu <- 45
tau <- 2.5 #variance of random starting points
nvalues <- 10
nfunctions <- 10
points_dist <- Curry(runif, min = 0, max = 1) #distribution of Ti
#learn true quantities from dataset powerconsumption ===========================
library(simulater)
library(fda)
df <- powerconsumption
df_list <- list()
for (idx in 1:nrow(df)) {
df_list[[idx]] <- list(
't' = seq(0, 1, length.out = 1440),
'x' = unname(unlist(as.vector(df[idx,])))
)
}
n_basis <- 9  #other tested setups 7
t0_list <- seq(.1, .9, l = 40)
grid <- seq(.1, .9, l = 101)
#df_smooth <- presmoothing(df_list, t0_list = t0_list, estimate_sigma(df_list))
df_smooth <- funestim::presmoothing(df_list, t0_list)
H0 <- funestim::estimate_H0(df_smooth)
L0 <- funestim::estimate_L0(df_smooth, H0, M)
true_tibble = tibble::tibble(t = t0_list, H = H0, L = L0, sigma = sigma,
mu0 = mu0)
basis <- create.fourier.basis(rangeval = c(min(t0_list), max(t0_list)),
nbasis = n_basis)
H0_smooth <- smooth.basis(argvals = t0_list, y = H0, fdParobj = basis)
L0_smooth <- smooth.basis(argvals = t0_list, y = L0, fdParobj = basis)
H0_eval <- eval.fd(evalarg = grid, fdobj = as.fd(H0_smooth))[, 1]
L0_eval <- eval.fd(evalarg = grid, fdobj = as.fd(L0_smooth))[, 1]
hurst_fun <- approxfun(
x = grid, y = H0_eval,
yleft = H0_eval[1], yright = H0_eval[length(H0_eval)]
)
constant_fun <- approxfun(
x = grid, y = L0_eval,
yleft = L0_eval[1], yright = L0_eval[length(L0_eval)]
)
grid_large <- seq(0, 1, l = 10001)
A_hat_prime <- constant_fun(grid_large)**(1 / hurst_fun(grid_large))
A_hat <- pracma::cumtrapz(x = grid_large, y = A_hat_prime)
A_fun <- approxfun(
x = grid_large, y = A_hat,
yleft = A_hat[1], yright = A_hat[length(A_hat)]
)
s <- exp(-3)  # Regularity for the estimation of the mean
##other tested setups 3
hurst_fun <- approxfun(
x = grid, y = H0_eval,
yleft = H0_eval[1], yright = H0_eval[length(H0_eval)]
)
#true mean
mu_model <- learn_mean(df, k = 50)
mu <- predict_mean(grid_mu, mu_model, lambda = s, k = 50) - 240
mu_t <- tibble::tibble(t = grid_mu, mu)
#tested discretisation error on grid of 1001 points - very small
grid_cov <- seq(0, 1, length.out = 101)
pp_disto <- A_fun(grid_cov)
cov_true <- tau**2 + covariance_mfbm(grid_cov, hurst_fun, pp_disto)
#obtain the "numerically true" eigenvalues from the true covariance
evalues_true <- eigen(cov_true, symmetric = TRUE,
only.values = TRUE)$values[1:nvalues] / length(grid_cov)
efunctions_true <- eigen(cov_true, symmetric = TRUE)$vectors[, 1:nvalues] *
sqrt(length(grid_cov))
#------------------------
#=======================
intermediate_directory <- './intermediate'
if (!dir.exists(intermediate_directory)){
dir.create(intermediate_directory)
}
n_simu = 5
cl <- parallel::makeCluster(9)
doParallel::registerDoParallel(cl)
tictoc::tic()
clusterExport(cl, as.vector(lsf.str())) # Register the functions and constant to // framework
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress=progress)
test = foreach::foreach(i = 1:n_simu,
.packages = c("dplyr", "MASS",
"purrr", "functional", "funeigen"),
.export=c("grid_bandwidth","grid_smooth", "k0", "nvalues", "sigma"),
.options.snow=opts) %dopar%
{
each_filename <- paste0('RESULT_N', N, '_M', M, '_', as.character(i),
'.rda')
each_filepath <- file.path(intermediate_directory, each_filename)
if (file.exists(each_filepath)) {
next
}
points_list <- generates_points(N = N, m = M)
pfbm <- generate_curves(points_list, hurst_fun,
distortion_model = A_fun,
add_regular_grid_of_size = grid_size_true,
sigma = sigma,
tau = tau,
L = L)
pfbm_curves <- lapply(pfbm$curves,
function(x) list(t = x$observed$t, x = x$observed$x,
grid_true = x$ideal$t,
x_true = x$ideal$x))
pfbm_mu <- lapply(pfbm_curves, function(curve) {
idx <- purrr::map_dbl(curve$t, ~which.min(abs(.x - mu_t$t)))
list(
t = curve$t,
x = curve$x + mu_t$mu[idx])
})
holder_estim <- estimate_holder_quantities(pfbm_mu, grid_param)
# cov_gkp <- covariance_ll(pfbm_mu, grid_bandwidth, grid_smooth, k0,
#                          holder_estim)
# elements_gkp <- funeigen:::normalise_eigen(cov_gkp$cov, nvalues = nvalues)
# evalues_gkp <- elements_gkp$values
# efunctions_gkp <- elements_gkp$vectors
# evalues_pw <- evalues_adaptive(pfbm_mu, grid_bandwidth, grid_smooth,
#                                k0, nvalues, holder_estim)
curves =  pfbm_mu
params = holder_estim
# smooth_curves <- smooth_curves_evalues(curves, grid_bandwidth,
#                                        grid_smooth, k0, nvalues, params)
# bw_vector <- estimate_bandwidth_evalues(curves, grid_bandwidth,
#                                         grid_smooth, k0,
#                                         nvalues, params)
# cov_gkp2 <- covariance_norm(curves, grid_bandwidth, grid_smooth,
#                            k0, params)
# grid_tibble = holder_estim
m <- purrr::map_dbl(curves, ~length(.x$t)) |> mean()
interp_grid <- c(0, params$t, 1)
var_interp <- as.matrix(params[, c("H", "L", "sigma", "mu0")])
interp_mat <- apply(var_interp, MARGIN = 2,
function(x) pracma::interp1(x = interp_grid,
y = c(x[1], x, x[nrow(var_interp)]),
xi = grid_smooth))
grid_tibble <- tibble::as_tibble(cbind(t = grid_smooth, interp_mat))
bandwidth_list <- estimate_bandwidth_covariance_norm(curves,
grid_bandwidth,
grid_smooth,
k0,
grid_tibble)
}
library(doSNOW)
install.packages("doSNOW")
library(doSNOW)
intermediate_directory <- './intermediate'
if (!dir.exists(intermediate_directory)){
dir.create(intermediate_directory)
}
n_simu = 5
cl <- parallel::makeCluster(9)
doParallel::registerDoParallel(cl)
tictoc::tic()
clusterExport(cl, as.vector(lsf.str())) # Register the functions and constant to // framework
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress=progress)
doSNOW::registerDoSNOW(cl)
test = foreach::foreach(i = 1:n_simu,
.packages = c("dplyr", "MASS",
"purrr", "functional", "funeigen"),
.export=c("grid_bandwidth","grid_smooth", "k0", "nvalues", "sigma"),
.options.snow=opts) %dopar%
{
each_filename <- paste0('RESULT_N', N, '_M', M, '_', as.character(i),
'.rda')
each_filepath <- file.path(intermediate_directory, each_filename)
if (file.exists(each_filepath)) {
next
}
points_list <- generates_points(N = N, m = M)
pfbm <- generate_curves(points_list, hurst_fun,
distortion_model = A_fun,
add_regular_grid_of_size = grid_size_true,
sigma = sigma,
tau = tau,
L = L)
pfbm_curves <- lapply(pfbm$curves,
function(x) list(t = x$observed$t, x = x$observed$x,
grid_true = x$ideal$t,
x_true = x$ideal$x))
pfbm_mu <- lapply(pfbm_curves, function(curve) {
idx <- purrr::map_dbl(curve$t, ~which.min(abs(.x - mu_t$t)))
list(
t = curve$t,
x = curve$x + mu_t$mu[idx])
})
holder_estim <- estimate_holder_quantities(pfbm_mu, grid_param)
# cov_gkp <- covariance_ll(pfbm_mu, grid_bandwidth, grid_smooth, k0,
#                          holder_estim)
# elements_gkp <- funeigen:::normalise_eigen(cov_gkp$cov, nvalues = nvalues)
# evalues_gkp <- elements_gkp$values
# efunctions_gkp <- elements_gkp$vectors
# evalues_pw <- evalues_adaptive(pfbm_mu, grid_bandwidth, grid_smooth,
#                                k0, nvalues, holder_estim)
curves =  pfbm_mu
params = holder_estim
# smooth_curves <- smooth_curves_evalues(curves, grid_bandwidth,
#                                        grid_smooth, k0, nvalues, params)
# bw_vector <- estimate_bandwidth_evalues(curves, grid_bandwidth,
#                                         grid_smooth, k0,
#                                         nvalues, params)
# cov_gkp2 <- covariance_norm(curves, grid_bandwidth, grid_smooth,
#                            k0, params)
# grid_tibble = holder_estim
m <- purrr::map_dbl(curves, ~length(.x$t)) |> mean()
interp_grid <- c(0, params$t, 1)
var_interp <- as.matrix(params[, c("H", "L", "sigma", "mu0")])
interp_mat <- apply(var_interp, MARGIN = 2,
function(x) pracma::interp1(x = interp_grid,
y = c(x[1], x, x[nrow(var_interp)]),
xi = grid_smooth))
grid_tibble <- tibble::as_tibble(cbind(t = grid_smooth, interp_mat))
bandwidth_list <- estimate_bandwidth_covariance_norm(curves,
grid_bandwidth,
grid_smooth,
k0,
grid_tibble)
}
intermediate_directory <- './intermediate'
if (!dir.exists(intermediate_directory)){
dir.create(intermediate_directory)
}
n_simu = 5
cl <- parallel::makeCluster(9)
doParallel::registerDoParallel(cl)
tictoc::tic()
clusterExport(cl, as.vector(lsf.str())) # Register the functions and constant to // framework
pb <- txtProgressBar(min=1, max=nrow(contexts), style=3)
intermediate_directory <- './intermediate'
if (!dir.exists(intermediate_directory)){
dir.create(intermediate_directory)
}
n_simu = 5
cl <- parallel::makeCluster(9)
doParallel::registerDoParallel(cl)
tictoc::tic()
clusterExport(cl, as.vector(lsf.str())) # Register the functions and constant to // framework
pb <- txtProgressBar(min=1, max=n_simu, style=3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress=progress)
doSNOW::registerDoSNOW(cl)
test = foreach::foreach(i = 1:n_simu,
.packages = c("dplyr", "MASS",
"purrr", "functional", "funeigen"),
.export=c("grid_bandwidth","grid_smooth", "k0", "nvalues", "sigma"),
.options.snow=opts) %dopar%
{
each_filename <- paste0('RESULT_N', N, '_M', M, '_', as.character(i),
'.rda')
each_filepath <- file.path(intermediate_directory, each_filename)
if (file.exists(each_filepath)) {
next
}
points_list <- generates_points(N = N, m = M)
pfbm <- generate_curves(points_list, hurst_fun,
distortion_model = A_fun,
add_regular_grid_of_size = grid_size_true,
sigma = sigma,
tau = tau,
L = L)
pfbm_curves <- lapply(pfbm$curves,
function(x) list(t = x$observed$t, x = x$observed$x,
grid_true = x$ideal$t,
x_true = x$ideal$x))
pfbm_mu <- lapply(pfbm_curves, function(curve) {
idx <- purrr::map_dbl(curve$t, ~which.min(abs(.x - mu_t$t)))
list(
t = curve$t,
x = curve$x + mu_t$mu[idx])
})
holder_estim <- estimate_holder_quantities(pfbm_mu, grid_param)
# cov_gkp <- covariance_ll(pfbm_mu, grid_bandwidth, grid_smooth, k0,
#                          holder_estim)
# elements_gkp <- funeigen:::normalise_eigen(cov_gkp$cov, nvalues = nvalues)
# evalues_gkp <- elements_gkp$values
# efunctions_gkp <- elements_gkp$vectors
# evalues_pw <- evalues_adaptive(pfbm_mu, grid_bandwidth, grid_smooth,
#                                k0, nvalues, holder_estim)
curves =  pfbm_mu
params = holder_estim
# smooth_curves <- smooth_curves_evalues(curves, grid_bandwidth,
#                                        grid_smooth, k0, nvalues, params)
# bw_vector <- estimate_bandwidth_evalues(curves, grid_bandwidth,
#                                         grid_smooth, k0,
#                                         nvalues, params)
# cov_gkp2 <- covariance_norm(curves, grid_bandwidth, grid_smooth,
#                            k0, params)
# grid_tibble = holder_estim
m <- purrr::map_dbl(curves, ~length(.x$t)) |> mean()
interp_grid <- c(0, params$t, 1)
var_interp <- as.matrix(params[, c("H", "L", "sigma", "mu0")])
interp_mat <- apply(var_interp, MARGIN = 2,
function(x) pracma::interp1(x = interp_grid,
y = c(x[1], x, x[nrow(var_interp)]),
xi = grid_smooth))
grid_tibble <- tibble::as_tibble(cbind(t = grid_smooth, interp_mat))
bandwidth_list <- estimate_bandwidth_covariance_norm(curves,
grid_bandwidth,
grid_smooth,
k0,
grid_tibble)
}
test[1]
tictoc::toc()
stopCluster(cl)
estimate_bandwidth_covariance_norm
