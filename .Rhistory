zw <- fdapace::FPCA(Ly = purrr::map(pfbm_mu, ~.x$x),
Lt = purrr::map(pfbm_mu, ~.x$t),
optns = list(nRegGrid = length(grid_smooth),
userBwCov = b,
methodSelectK = nelements))
time_zw <- difftime(Sys.time(), a, units = "secs")
})
zw_list[[1]]
zw_list
zw_list <- lapply(zw_bw_grid, function(b) {
a <- Sys.time()
zw <- fdapace::FPCA(Ly = purrr::map(pfbm_mu, ~.x$x),
Lt = purrr::map(pfbm_mu, ~.x$t),
optns = list(nRegGrid = length(grid_smooth),
userBwCov = b,
methodSelectK = nelements))
time_zw <- difftime(Sys.time(), a, units = "secs")
list(time = time_zw,
zw = zw)
})
zw_list[[1]]$zw$phi
N
M
M = 50
library(fda)
library(foreach)
library(fs)
library(doParallel)
library(functional)
library(purrr)
library(FDAdapt)
library(np)
# Set parameters for simulations
N <- 100
M <- 50
sigma0 <- 0.25
mu0 <- 1
grid_size_true <- 101
grid_true <- seq(0, 1, length.out = grid_size_true)
grid_mu <- seq(0, 1, length.out = 1001)
grid_smooth <- seq(0, 1, length.out = 101)
grid_param <- seq(0.1, 0.9, length.out = 40)
k0 <- 1
n_simu <- 100
points_dist <- Curry(runif, min = 0, max = 1) #distribution of Ti
grid_large <- seq(0, 1, l = 10001)
learn_set <- 20
q_FPCA <- 0.5
# Learn true quantities from powerconsuption dataset =======================
# Reshape data set
load("~/FDAdapt/data/powerconsumption.rda")
df <- powerconsumption
df_list <- list()
for (idx in 1:nrow(df)) {
df_list[[idx]] <- list(
't' = seq(0, 1, length.out = 1440),
'x' = unname(unlist(as.vector(df[idx,])))
)
}
# Number of basis functions used to smooth H and L
n_basis <- 8
# Estimation grid for H, L and v
t0_list <- seq(0, 1, length.out = 40)
# Estimate H, L and v
param_estim <- estimate_regularity_dense(data = df_list,
xout = t0_list,
method = "linear",
gamma_H = 0.75,
gamma_L = 0.3)
H0_estim <- param_estim$H
L0_estim <- param_estim$L
var_estim <- estimate_variance_irreg(df_list, grid_estim = t0_list)
# Interpolate H, L, v onto larger grid to define functionals
H0 <- stats::approx(x = t0_list,
y = H0_estim,
xout = grid_large,
method = "linear",
yleft = H0_estim[1],
yright = H0_estim[length(H0_estim)])
L0 <- stats::approx(x = t0_list,
y = L0_estim,
xout = grid_large,
method = "linear",
yleft = L0_estim[1],
yright = L0_estim[length(L0_estim)])
v0 <- stats::approx(x = t0_list,
y = var_estim,
xout = grid_large,
method = "linear",
yleft = var_estim[1],
yright = var_estim[length(var_estim)])
# Smooth estimated parameters
basis <- create.fourier.basis(rangeval = c(min(grid_large), max(grid_large)),
nbasis = n_basis)
H0_smooth <- smooth.basis(argvals = grid_large, y = H0$y, fdParobj = basis)
L0_smooth <- smooth.basis(argvals = grid_large, y = L0$y, fdParobj = basis)
var_smooth <- smooth.basis(argvals = grid_large, y = v0$y, fdParobj = basis)
H0_eval <- eval.fd(evalarg = grid_large, fdobj = as.fd(H0_smooth))[, 1]
L0_eval <- eval.fd(evalarg = grid_large, fdobj = as.fd(L0_smooth))[, 1]
var_eval <- eval.fd(evalarg = grid_large, fdobj = as.fd(var_smooth))[, 1]
# Convert vectors into functions
hurst_fun <- approxfun(
x = grid_large, y = H0_eval,
yleft = H0_eval[1], yright = H0_eval[length(H0_eval)]
)
constant_fun <- approxfun(
x = grid_large, y = L0_eval,
yleft = L0_eval[1], yright = L0_eval[length(L0_eval)]
)
var_fun <- approxfun(
x = grid_large, y = var_eval,
yleft = var_eval[1], yright = var_eval[length(var_eval)]
)
# Build time deformation A(t) using v, L and H
C0 <- 0
Ct <- (L0_eval / var_eval)**(1 / H0_eval)
Ct_int <- pracma::cumtrapz(x = grid_large, y = Ct)
A_hat <- exp(C0 + Ct_int)
A_fun <- approxfun(
x = grid_large, y = A_hat,
yleft = A_hat[1], yright = A_hat[length(A_hat)]
)
# Construct True Mean from dat set
mu_model <- learn_mean(df, k = 50)
# Regularity parameter for mean estimation
s <- exp(-3)
mu <- predict_mean(grid_mu, mu_model, lambda = s, k = 50, scale = TRUE)
mu_t <- tibble::tibble(t = grid_mu, mu)
# Construct true covariance function
grid_cov <- seq(0, 1, length.out = 101)
pp_disto <- A_fun(grid_cov)
cov_inter <- covariance_mfbm(grid_cov, hurst_fun, pp_disto)
bi_gridcov <- expand.grid(s = grid_cov, t = grid_cov)
cov_true <- sqrt(var_fun(bi_gridcov$s)) * sqrt(var_fun(bi_gridcov$t)) *
A_fun(bi_gridcov$t)**(-hurst_fun(bi_gridcov$t)) *
A_fun(bi_gridcov$s)**(-hurst_fun(bi_gridcov$s)) * cov_inter
# Obtain the "numerically true" eigenvalues from the true covariance
evalues_true <- eigen(cov_true, symmetric = TRUE,
only.values = TRUE)$values[1:20] / length(grid_cov)
efunctions_true <- eigen(cov_true, symmetric = TRUE)$vectors[, 1:20] *
sqrt(length(grid_cov))
# Explained variance of eigenvalues - first 9 captures 99% of variation
cumsum(evalues_true) / sum(evalues_true)
nelements <- 9
evalues_true <- evalues_true[1:nelements]
efunctions_true <- efunctions_true[, 1:nelements]
GA::persp3D(grid_cov, grid_cov, cov_true)
==========================================
intermediate_directory <- './intermediate'
if (!dir.exists(intermediate_directory)){
dir.create(intermediate_directory)
}
cl <- parallel::makeCluster(40)
doParallel::registerDoParallel(cl)
doSNOW::registerDoSNOW(cl)
pb <- txtProgressBar(min = 1, max = n_simu, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts <- list(progress = progress)
tictoc::tic()
foreach::foreach(i = 1:n_simu,
.packages = c("dplyr", "MASS",
"purrr", "functional", "FDAdapt", "np"),
.options.snow = opts) %dopar%
{
each_filename <- paste0('RESULT_N', N, '_M', M, '_', as.character(i),
'.rda')
each_filepath <- file.path(intermediate_directory, each_filename)
if (file.exists(each_filepath)) {
next
}
# Generate sampling points
points_list <- generate_points(N = N, m = M)
# Generate curves using H, L, v from before
pfbm <- generate_curves(points_list, hurst_fun,
distortion_model = A_fun,
variance_fun = var_fun,
sigma0 = sigma0,
hetero = TRUE,
regular_grid = grid_true)
# Reshape generated curves into list
pfbm_list <- purrr::map(pfbm$curves,
~list(t = .x$observed$t,
x = .x$observed$x))
pfbm_mu <- lapply(pfbm_list, function(curve) {
idx <- purrr::map_dbl(curve$t, ~which.min(abs(.x - mu_t$t)))
list(t = curve$t,
x = curve$x + mu_t$mu[idx])
})
mbar <- purrr::map_dbl(pfbm_list, ~length(.x$t)) |> mean()
param_grid <- seq(0, 1, l = round(mbar / 3))
# params_true <- list(
#   t = param_grid,
#   H = hurst_fun(param_grid),
#   L = constant_fun(param_grid),
#   sigma = sigma
# )
# Left endpoint based on sparse condition
h_left <- log(N) / (mbar * sqrt(N))
# Right endpoint of bandwidth grid, set to 15% of the length of interval.
h_max <- 0.1 * (pfbm$t_max - pfbm$t_min)
#grid_bandwidth <- lseq(1 / Mi_max, h_max, length.out = 51)
grid_bandwidth <- lseq(h_left, h_max, length.out = 61)
a <- Sys.time()
wpk_adapt <- FPCA_adapt(data = pfbm_list,
grid_smooth = grid_smooth,
grid_bw = grid_bandwidth,
grid_param = param_grid,
cv_set = learn_set,
quantile = q_FPCA,
inflate_bw = TRUE,
center = TRUE,
interp_method = "linear",
nelements = nelements,
gamma_H = 0.75,
gamma_L = 0.7,
h_power = 0.9,
intp_param = TRUE)
time_wpk <- difftime(Sys.time(), a, units = "secs")
zw_bw_grid <- seq(h_left, 0.1, l = 3)
zw_list <- lapply(zw_bw_grid, function(b) {
a <- Sys.time()
zw <- fdapace::FPCA(Ly = purrr::map(pfbm_mu, ~.x$x),
Lt = purrr::map(pfbm_mu, ~.x$t),
optns = list(nRegGrid = length(grid_smooth),
userBwCov = b,
methodSelectK = nelements))
time_zw <- difftime(Sys.time(), a, units = "secs")
list(time = time_zw,
zw = zw)
})
result <- list(
"wpk" = wpk_adapt,
"zw" = zw_list
)
save(result, file = each_filepath)
}
tictoc::toc()
stopCluster(cl)
fls <- list.files(intermediate_directory, pattern = 'rda')
result_list <- lapply(fls,
function(x) get(eval(load(paste0(intermediate_directory, '/', x
)))))
#assign(paste0('result', '_N', N, '_M', M, '_delta', delta_p[j]), result_list)
save(result_list,
file = paste0('~/simu_final_allmatched/result', '_N', N, '_M', M,
'.rda'))
path <- paste0(getwd(), '/intermediate')
file_delete(path)
load("~/simu_final_allmatched/result_N100_M50.rda")
result_list[[1]]$wpk
library(dplyr)
library(stringr)
library(purrr)
library(forcats)
library(readr)
library(ggplot2)
library(patchwork)
library(tidyr)
library(reshape2)
result_list[[1]]$wpk$evalues
result_list[[1]]$zw[[1]]$zw$lambda
result_list[[1]]$zw[[2]]$zw$lambda
result_list[[1]]$zw[[3]]$zw$lambda
zw_ratio_val <- sapply(seq_len(3), function(y) {
map(result_list, ~abs(.x$wpk$evalues - evalues_true) /
abs(.x$zw[[y]]$zw$lambda - evalues_true)) |>
(\(x) do.call(rbind, x))()
})
zw_ratio_val
result_list[[1]]$wpk$evalues
length(result_list)
zw_ratio_val <- sapply(seq_len(3), function(y) {
map(result_list, ~abs(.x$wpk$evalues - evalues_true) /
abs(.x$zw[[y]]$zw$lambda - evalues_true))
})
zw_ratio_val
zw_ratio_val <- lapply(seq_len(3), function(y) {
map(result_list, ~abs(.x$wpk$evalues - evalues_true) /
abs(.x$zw[[y]]$zw$lambda - evalues_true))
})
zw_ratio_val[[1]]
zw_ratio_val <- lapply(seq_len(3), function(y) {
sapply(result_list, function(x) abs(x$wpk$evalues - evalues_true) /
abs(x$zw[[y]]$zw$lambda - evalues_true))
})
zw_ratio_val
zw_ratio_val[[1]]
zw_ratio_val <- lapply(seq_len(3), function(y) {
sapply(result_list, function(x) abs(x$wpk$evalues - evalues_true) /
abs(x$zw[[y]]$zw$lambda - evalues_true)) |>
t() |> as.data.frame() |>
pivot_longer(cols = V1:V9)
})
zw_ratio_val[[1]]
valplot <- ggplot(zw_ratio_val,
aes(x = name,
y = value,
fill = name)) +
geom_boxplot(outlier.shape = NA) +
xlab(" ") +
ylab("RMSE Ratio") +
geom_hline(yintercept = 1, col = "red") +
scale_y_continuous(limits = quantile(filter(zw_ratio_val,
name == paste0("V", 1:4))$value,
c(0.05, 0.95))) +
theme_minimal() +
ggtitle(label = "Eigenvalues")
length(zw_ratio_val)
valplot <- lapply(zw_ratio_val, function(z) {
ggplot(zw_ratio_val,
aes(x = name,
y = value,
fill = name)) +
geom_boxplot(outlier.shape = NA) +
xlab(" ") +
ylab("RMSE Ratio") +
geom_hline(yintercept = 1, col = "red") +
scale_y_continuous(limits = quantile(filter(zw_ratio_val,
name == paste0("V", 1:4))$value,
c(0.05, 0.95))) +
theme_minimal() +
ggtitle(label = "Eigenvalues")
})
valplot <- lapply(zw_ratio_val, function(z) {
ggplot(z,
aes(x = name,
y = value,
fill = name)) +
geom_boxplot(outlier.shape = NA) +
xlab(" ") +
ylab("RMSE Ratio") +
geom_hline(yintercept = 1, col = "red") +
scale_y_continuous(limits = quantile(filter(z,
name == paste0("V", 1:4))$value,
c(0.05, 0.95))) +
theme_minimal() +
ggtitle(label = "Eigenvalues")
})
valplot
result_list[[1]]$wpk$efunctions
wpk_err <- map(result_list,
~apply((normalise_sign(.x$wpk$efunctions, efunctions_true) -
efunctions_true)**2, 2, function(x) pracma::trapz(grid_smooth, x))) |>
(\(x) do.call(rbind, x))()
wpk_err
result_list[[1]]$zw[[1]]$zw$phi
result_list[[1]]$zw[[1]]$zw$phi
normalise_sign(result_list[[1]]$zw[[1]]$zw$phi, efunctions_true)
apply((normalise_sign(result_list[[1]]$zw[[1]]$zw$phi, efunctions_true) - efunctions_true)^2, 2, function(x) pracma::trapz(grid_smooth, x))
zw_err <- lapply(result_list, function(r) {
sapply(seq_len(3), function(h) {
apply((normalise_sign(r$zw[[h]]$zw$phi, efunctions_true) - efunctions_true)^2,
2, function(x) pracma::trapz(grid_smooth, x))
})
})
zw_err
zw_err <- sapply(seq_len(3), function(h) {
lapply(result_list, function(r) {
apply((normalise_sign(r$zw[[h]]$zw$phi, efunctions_true) - efunctions_true)^2,
2, function(x) pracma::trapz(grid_smooth, x))
})
})
zw_err
zw_err <- lapply(seq_len(3), function(h) {
sapply(result_list, function(r) {
apply((normalise_sign(r$zw[[h]]$zw$phi, efunctions_true) - efunctions_true)^2,
2, function(x) pracma::trapz(grid_smooth, x))
})
})
zw_err
zw_err <- lapply(seq_len(3), function(h) {
sapply(result_list, function(r) {
apply((normalise_sign(r$zw[[h]]$zw$phi, efunctions_true) - efunctions_true)^2,
2, function(x) pracma::trapz(grid_smooth, x))
}) |> t() |> as.data.frame() |> pivot_longer(V1:V9)
})
zw_err[[1]]
wpk_err
zw_err[[3]]
wpk_err <- map(result_list,
~apply((normalise_sign(.x$wpk$efunctions, efunctions_true) -
efunctions_true)**2, 2, function(x) pracma::trapz(grid_smooth, x))) |>
(\(x) do.call(rbind, x))() |>
as.data.frame() |>
pivot_longer(V1:V9)
wpk_err
wpk_err <- map(result_list,
~apply((normalise_sign(.x$wpk$efunctions, efunctions_true) -
efunctions_true)**2, 2, function(x) pracma::trapz(grid_smooth, x))) |>
(\(x) do.call(rbind, x))()
zw_err <- lapply(seq_len(3), function(h) {
sapply(result_list, function(r) {
apply((normalise_sign(r$zw[[h]]$zw$phi, efunctions_true) - efunctions_true)^2,
2, function(x) pracma::trapz(grid_smooth, x))
})
})
wpk_err
zw_err
zw_err <- lapply(seq_len(3), function(h) {
sapply(result_list, function(r) {
apply((normalise_sign(r$zw[[h]]$zw$phi, efunctions_true) - efunctions_true)^2,
2, function(x) pracma::trapz(grid_smooth, x))
}) |> t()
})
zw_err
zw_err[[1]]
wpk_err
wpk_err |> dim()
zw_err[[1]] |> dim()
ratio_fun <- lapply(zw_err, function(z) {
as.data.frame(sqrt(wpk_err / z)) |>
pivot_longer(V1:V9)
})
ratio_fun[[1]]
funplot <- lapply(ratio_fun, function(x) {
ggplot(x,
aes(x = name,
y = value,
fill = name)) +
geom_boxplot(outlier.shape = NA) +
xlab(" ") +
ylab("L2 Norm Ratio") +
geom_hline(yintercept = 1, col = "red") +
scale_y_continuous(limits = quantile(ratio_fun$value, c(0.05, 0.95))) +
theme_minimal() +
ggtitle(label = "Eigenfunctions")
})
funplot
valplot
result_list[[1]]$wpk$efunctions
test_wpk = normalise_sign(result_list[[1]]$wpk$efunctions, efunctions_true)
test_wok
test_wpk
test_zw = normalise_sign(result_list[[1]]$zw[[1]]$zw$phi, efunctions_true)
test_zw
test_wpk = apply((normalise_sign(result_list[[1]]$wpk$efunctions, efunctions_true) - efunctions_true)^2, 2, function(x) pracma::trapz(grid_smooth, x))
test_wpk
test_zw = apply((normalise_sign(result_list[[1]]$zw[[1]]$zw$phi, efunctions_true) - efunctions_true)^2, 2, function(x) pracma::trapz(grid_smooth, x))
test_zw
test_wpk / test_zw
test_zw = apply((normalise_sign(result_list[[1]]$zw[[3]]$zw$phi, efunctions_true) - efunctions_true)^2, 2, function(x) pracma::trapz(grid_smooth, x))
test_wpk / test_zw
sqrt(test_wpk / test_zw)
sqrt(test_wpk / test_zw)
test_zw = apply((normalise_sign(result_list[[58]]$zw[[3]]$zw$phi, efunctions_true) - efunctions_true)^2, 2, function(x) pracma::trapz(grid_smooth, x))
test_wpk = apply((normalise_sign(result_list[[58]]$wpk$efunctions, efunctions_true) - efunctions_true)^2, 2, function(x) pracma::trapz(grid_smooth, x))
sqrt(test_wpk / test_zw)
plot(grid_smooth, efunctions_true[, 1], type = "l")
lines(grid_smooth, result_list[[58]]$wpk$efunctions[, 1], col = "red")
lines(grid_smooth, result_list[[58]]$zw[[3]]$zw$phi[, 1], col = "blue")
lines(grid_smooth, result_list[[58]]$zw[[3]]$zw$phi[, 1] * (-1), col = "blue")
pracma::trapz(grid_smooth, (result_list[[58]]$wpk$efunctions[, 1] - efunctions_true[, 1])^2)
sqrt(pracma::trapz(grid_smooth, (result_list[[58]]$wpk$efunctions[, 1] - efunctions_true[, 1])^2))
sqrt(pracma::trapz(grid_smooth, (result_list[[58]]$zw[[3]]$zw$phi[, 1] - efunctions_true[, 1])^2))
rm(test_wpk)
rm(test_zw)
combined_plot <- lapply(funplot, function(f) {
valplot + f + plot_layout(guides = "collect") &
theme(legend.position = "bottom")
})
library(patchwork)
combined_plot <- lapply(funplot, function(f) {
valplot + f + plot_layout(guides = "collect") &
theme(legend.position = "bottom")
})
funplot[[1]]
combined_plot <- lapply(funplot, function(f) {
valplot + f +
plot_layout(guides = "collect") &
theme(legend.position = "bottom")
})
library(patchwork)
combined_plot <- lapply(funplot, function(f) {
valplot + f +
plot_layout(guides = "collect") &
theme(legend.position = "bottom")
})
valplot
combined_plot <- purrr::map2(valplot, funplot, ~.x, + .y +
plot_layout(guides = "collect") &
theme(legend.position = "bottom"))
combined_plot[[1]]
combined_plot <- lapply(seq_len(3), function(x) {
val_plot[[x]] + funplot[[y]] +
plot_layout(guides = "collect") &
theme(legend.position = "bottom")
})
combined_plot <- lapply(seq_len(3), function(x) {
valplot[[x]] + funplot[[y]] +
plot_layout(guides = "collect") &
theme(legend.position = "bottom")
})
library(patchwork)
combined_plot <- lapply(seq_len(3), function(x) {
valplot[[x]] + funplot[[x]] +
plot_layout(guides = "collect") &
theme(legend.position = "bottom")
})
combined_plot[[1]]
combined_plot[[2]]
combined_plot[[3]]
result_list[[1]]$zw[[1]]$time
result_list[[1]]$zw[[1]]$time
N = 100
M = 100
exp(-log(100)*0.75)
exp(-log(100)**0.75)
exp(-log(100)**0.7)
getwd()
setwd("/home/swang/FDAdapt")
devtools::document()
5 * 5
