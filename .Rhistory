h_constant_fun <- log(1 / h_star_fun)
h_star_val <- h_constant_val * h_star_val
h_star_fun <- h_constant_fun * h_star_fun
}
# Return h_star
list(bw_val= h_star_val,
bw_fun = h_star_fun)
}
bw_FPCA(data = data, param_smooth = param_list, h_grid = lseq(0.001, 0.1, l = 61), t_grid = seq(0, 1, l = 101),  psi_mat = prelim$efunctions, lambda_vec = prelim$evalues, inflate = TRUE)
bw_FPCA
args(bw_FPCA)
eelements_prelim <- FPCA(data = data,
grid_smooth = seq(0, 1, l = 101),
grid_bw = lseq(0.001, 0.1, l = 61),
param_list = param_list,
inflate_bw = TRUE,
center = FALSE,
nelements =10,
diag_cor = TRUE,
h_power = 0.9)
eelements_prelim$params
args(bw_FPCA)
bw_adaptive <- bw_FPCA(data = data,
param_smooth = eelements_prelim$params,
h_grid = lseq(0.005, 0.1, l = 61),
t_grid = seq(0, 1, l = 101),
psi_mat = eelements_prelim$efunctions,
lambda_vec = eelements_prelim$evalues,
inflate = TRUE,
interp_type = "linear")
bw_adaptive$bw_val
bw_adaptive$bw_fun
cov_ISE
t_smooth
t_smooth = seq(0, 1, l = 101)
h
val_adapt
cov_FPCA
var_tss
dim(var_tss)
param_smooth = param_list
h_grid = lseq(0.001, 0.1, l = 61)
t_grid = seq(0, 1, l = 101)
psi_mat = eelements_prelim$efunctions
lambda_vec = eelements_prelim$evalues
cst_kernel <- 1.5 * (1 / (1 + 2*param_smooth$H) - 1 / (3 + 2*param_smooth$H))
# Compute bias term of eigenvalues ==========================================
bias_rate_val <- bias_kernel(H = param_smooth$H,
L = param_smooth$L,
cst = cst_kernel,
h_grid = h_grid)
bias_t_val <- apply(psi_mat**2, 2,
function(x) sweep(bias_rate_val, 2, x, FUN = "*") |>
apply(1, function(y) pracma::trapz(t_grid, y)))
# Compute integrated bias at s
bias_s_val <- apply(psi_mat**2, 2,
function(x) pracma::trapz(t_grid,
param_smooth$moments2 * x))
# Compute bias term
bias_term_val <- sweep(bias_t_val, 2, bias_s_val, FUN = "*")
#End of bias term for eigenvalues ===========================================
# Compute bias terms of eigenfunctions ======================================
bias_ss <- sapply(seq_len(ncol(psi_mat)), function(j) {
sapply(seq_along(h_grid), function(h) {
apply(bias_rate_val[h, ] * psi_mat[, -j]**2,
2,
function(x) pracma::trapz(t_grid, x))
}, simplify = "array")
}, simplify = "array")
bias_st <- apply(psi_mat**2, 2, function(x) param_smooth$moments2 * x) |>
apply(2, function(x) pracma::trapz(t_grid, x))
bias_s_fun <- sweep(bias_ss,
3,
bias_st,
FUN = "*")
bias_tt <- apply(psi_mat**2,
2,
function(x)
apply(x * bias_rate_val,
1,
function(y) pracma::trapz(t_grid, y)
)
)
bias_ts <- sapply(seq_len(ncol(psi_mat)), function(j) {
apply(psi_mat[, -j]**2 * param_smooth$moments2,
2,
function(x) pracma::trapz(t_grid, x)
)
}, simplify = "array")
bias_t_fun <- sapply(seq_along(h_grid), function(h) {
sweep(bias_ts,
2,
bias_tt[h, ],
FUN = "*"
)
}, simplify = "array") |>
aperm(c(1, 3, 2))
# Compute bias constants
fun_cst <- sapply(seq_along(lambda_vec),
function(j) (lambda_vec[j] - lambda_vec[-j])**(-2))
bias_term_fun <- sapply(seq_len(ncol(psi_mat)), function(j) {
colSums(fun_cst[, j] * (bias_t_fun[,, j] + bias_s_fun[,, j]))
}, simplify = "array")
# End of bias computation for eigenfunctions ================================
# Compute variance term for eigenvalues =====================================
# Compute variance at s
var_s_num_val <- tcrossprod(param_smooth$sigma**2, param_smooth$moments2)
# Compute Ngamma
Ngamma <- N_gamma(curves = data,
x = t_grid,
bw = h_grid)
N_gamma
var_s_num_val
dim(Ngamma$Ngamma)
apply(Ngamma$Ngamma, 3, function(x) var_s_num_val / x)
apply(Ngamma$Ngamma, 3, function(x) var_s_num_val / x, simplify = FALSE)
var_Sts
var_sts
dim(var_sts)
apply(Ngamma$Ngamma[,, 1])
apply(Ngamma$Ngamma, 3, function(x) var_s_num_val / x, simplify = FALSE)
# Compute variance for eigenfunctions =======================================
var_tst <- psi_mat**2 * param_smooth$moments2
var_tss <- sapply(seq_len(ncol(psi_mat)), function(j) {
psi_mat[, -j]**2 * param_smooth$sigma**2
}, simplify = "array")
apply(Ngamma$Ngamma, 3, function(x) apply(var_tss, 1, function(y) y / x) )
N_gamma
?mapply
dim(psi_mat)
?setdiff
seq_len(ncol(psi_mat))
setdiff(seq_len(ncol(psi_mat)), seq_len(ncol(psi_mat)))
sapply(seq_len(ncol(psi_mat)), function(j) setdiff(j, seq_len(ncol(psi_mat))))
dim(bias_Rate_val)
bias_rate_val
dim(bias_rate_val)
dim(psi_mat)
dim(psi_mat[, -1])
list(bias_rate_val, psi_mat[, -1])
dim(bias_rate_val)
dim(psi_mat[, -1])
apply(bias_rate_val, 1, function(x) x * psi_mat[, -1])
apply(bias_rate_val, 1, function(x) x * psi_mat[, -1], simplify = FALSE)
apply(bias_rate_val, 1, function(x) x * psi_mat[, -1], simplify = FALSE)[[1]] |? dim()
apply(bias_rate_val, 1, function(x) x * psi_mat[, -1], simplify = FALSE)[[1]] |> dim()
var_s_num_val
dim(var_s_num_val)
dim(var_term_val)
# Compute variance term
var_term_val <- sapply(seq_len(ncol(psi_mat)), function(j) {
sapply(seq_along(h_grid), function(h) {
(var_s_num_val / Ngamma$Ngamma[,, h] +
t(var_s_num_val) / t(Ngamma$Ngamma[,,h])) *
tcrossprod(psi_mat[, j]**2)
}, simplify = "array")
}, simplify = "array") |>
apply(c(2, 3, 4), function(x) pracma::trapz(t_grid, x)) |>
apply(c(2, 3), function(x) pracma::trapz(t_grid, x))
dim(var_term_val)
test_val <- apply(Ngamma$Ngamma,
3,
function(Ngamma) var_s_num_val / Ngamma +
t(var_s_num_val) / t(Ngamma))
dim(test_val)
test_val <- apply(Ngamma$Ngamma,
3,
function(Ngamma) var_s_num_val / Ngamma +
t(var_s_num_val) / t(Ngamma),
simplify = FALSE)
test_val
dim(test_val[[1]])
test_val <- apply(Ngamma$Ngamma,
3,
function(Ngamma) (var_s_num_val / Ngamma +
t(var_s_num_val) / t(Ngamma)) *
apply(psi_mat**2, 2, function(x) tcrossprod(x),
simplify = FALSE),
simplify = FALSE)
test_val <- apply(Ngamma$Ngamma,
3,
function(Ngamma)
apply(psi_mat**2, 2, function(psi) {
(var_s_num_val / Ngamma +
t(var_s_num_val) / t(Ngamma)) *
tcrossprod(psi)
}, simplify = FALSE),
simplify = FALSE)
test_val
length(test_val)
dim(test_val[[1]])
test_val[[1]]
test_val[[1]][[1]] |> dim()
length(test_val[[1]])
dim(var_tss)
dim(var_tst)
dim(Ngamma$Ngamma)
dim(var_s_num_val)
sweep(Ngamma$Ngamma, c(1, 2), var_s_num_val, FUN = "/")
sweep(Ngamma$Ngamma, c(1, 2), var_s_num_val, FUN = "/") |> dim()
sweep(Ngamma$Ngamma, c(1, 2), var_s_num_val, function(x, y) y / x) |
sweep(Ngamma$Ngamma, c(1, 2), var_s_num_val, function(x, y) y / x)
sweep(Ngamma$Ngamma, c(1, 2), var_s_num_val, function(x, y) y / x)  |> dim()
+ sweep(Ngamma$Ngamma, c(1, 2), var_s_num_val, function(x, y) t(y) / t(x))
+ sweep(Ngamma$Ngamma, c(1, 2), var_s_num_val, function(x, y) t(y) / t(x))
dim(var_s_num_val)
dim(Ngamma$Ngamma)
apply(Ngamma$Ngamma, c(1, 2), function(x) var_s_num_val / x + t(var_s_num_val) / t(x))
apply(Ngamma$Ngamma, 3, function(x) var_s_num_val / x + t(var_s_num_val) / t(x))
apply(Ngamma$Ngamma, 3, function(x) var_s_num_val / x + t(var_s_num_val) / t(x), simplify = FALSE)
test_val <- apply(Ngamma$Ngamma,
3,
function(x) (var_s_num_val / x) +
(t(var_s_num_val) / t(x)), simplify = FALSE)
test_val[[1]]
test_val[[1]] |> dim()
tcrossprod(psi_mat)
apply(psi_mat**2, 2, tcrossprod)
apply(psi_mat**2, 2, tcrossprod, simplify = FALSE)
test_val2 <- apply(psi_mat**2, 2, tcrossprod, simplify = FALSE)
length(test_val)
length(test_val2)
dim(test_val[[1]])
dim(test_val2)
dim(test_val2[[1]])
purrr::map2(test_val, test_val2, ~.x + .y)
plyr::aaply(Ngamma$Ngamma, 3, function(x) var_s_num_val / x + t(var_s_num_val) / t(x))
plyr::aaply(Ngamma$Ngamma, 3, function(x) var_s_num_val / x + t(var_s_num_val) / t(x)) |> dim()
sapply(seq_len(ncol(psi_mat)), function(j) {
plyr::aaply(Ngamma$Ngamma,
3,
function(x) var_s_num_val / x + t(var_s_num_val) / t(x) *
tcrossprod(psi_mat[, j]**2))
}, simplify = "array")
sapply(seq_len(ncol(psi_mat)), function(j) {
plyr::aaply(Ngamma$Ngamma,
3,
function(x) var_s_num_val / x + t(var_s_num_val) / t(x) *
tcrossprod(psi_mat[, j]**2))
}, simplify = "array") |> dim()
sapply(seq_len(ncol(psi_mat)), function(j) {
plyr::aaply(Ngamma$Ngamma,
3,
function(x) var_s_num_val / x + t(var_s_num_val) / t(x) *
tcrossprod(psi_mat[, j]**2))
}, simplify = "array") |>
apply(c(1, 3, 4), function(x) pracma::trapz(t_grid, x)) |>
apply(c(1, 3), function(x) pracma::trapz(t_grid, x))
sapply(seq_len(ncol(psi_mat)), function(j) {
plyr::aaply(Ngamma$Ngamma,
3,
function(x) var_s_num_val / x + t(var_s_num_val) / t(x) *
tcrossprod(psi_mat[, j]**2))
}, simplify = "array") |>
apply(c(1, 3, 4), function(x) pracma::trapz(t_grid, x)) |>
apply(c(1, 3), function(x) pracma::trapz(t_grid, x)) |> dim()
test_val <- sapply(seq_len(ncol(psi_mat)), function(j) {
plyr::aaply(Ngamma$Ngamma,
3,
function(x) var_s_num_val / x + t(var_s_num_val) / t(x) *
tcrossprod(psi_mat[, j]**2))
}, simplify = "array") |>
apply(c(1, 3, 4), function(x) pracma::trapz(t_grid, x)) |>
apply(c(1, 3), function(x) pracma::trapz(t_grid, x))
dim(test_val)
dim(var_term_val)
all.equal(test_val, var_term_val)
all.equal(test_val, var_term_val, check.attributes = FALSE)
test_val <- sapply(seq_len(ncol(psi_mat)), function(j) {
plyr::aaply(Ngamma$Ngamma,
3,
function(x) (var_s_num_val / x) + (t(var_s_num_val) / t(x)) *
tcrossprod(psi_mat[, j]**2))
}, simplify = "array") |>
apply(c(1, 3, 4), function(x) pracma::trapz(t_grid, x)) |>
apply(c(1, 3), function(x) pracma::trapz(t_grid, x))
tictoc::tic()
var_term_val <- sapply(seq_len(ncol(psi_mat)), function(j) {
sapply(seq_along(h_grid), function(h) {
(var_s_num_val / Ngamma$Ngamma[,, h] +
t(var_s_num_val) / t(Ngamma$Ngamma[,,h])) *
tcrossprod(psi_mat[, j]**2)
}, simplify = "array")
}, simplify = "array") |>
apply(c(2, 3, 4), function(x) pracma::trapz(t_grid, x)) |>
apply(c(2, 3), function(x) pracma::trapz(t_grid, x))
tictoc::toc()
tictoc::tic()
test_val <- sapply(seq_len(ncol(psi_mat)), function(j) {
plyr::aaply(Ngamma$Ngamma,
3,
function(x) (var_s_num_val / x) + (t(var_s_num_val) / t(x)) *
tcrossprod(psi_mat[, j]**2))
}, simplify = "array") |>
apply(c(1, 3, 4), function(x) pracma::trapz(t_grid, x)) |>
apply(c(1, 3), function(x) pracma::trapz(t_grid, x))
tictoc::toc()
all.equal(test_val, var_term_val, check.attributes = FALSE)
mu
mu <- purrr::imap(smoothed$smoothed_curves,
~.x * wi[, .y]) |>
(\(x) Reduce('+', x) / WN)()
t_smooth
h
h = bw_adaptive$bw_val[1]
h
data
h
h_power
h_power = 0.9
# Smooth curves at optimal bandwidth
smoothed <- smooth_curves(data = data, grid = t_smooth, bandwidth = h)
# Compute wi(t)
wi <- curves_select(curves = data,
x = t_smooth,
h = h)
# Compute wi(s)
WN <- rowSums(wi)
mu <- purrr::imap(smoothed$smoothed_curves,
~.x * wi[, .y]) |>
(\(x) Reduce('+', x) / WN)()
mu
smoothed_curves <- sapply(smoothed$smoothed_curves,
function(x) x - mu)
smoothed_curves
dim(smoothed_curves)
dim(wi)
# Compute cov
Gamma <- apply(wi * smoothed_curves,
2,
tcrossprod)
Gamma
# Compute cov
Gamma <- apply(wi * smoothed_curves,
2,
tcrossprod,
simplify = FALSE)
length(Gamma)
Gamma[[1]] |> dim()
# Compute cov
Gamma <- apply(wi * smoothed_curves,
2,
tcrossprod,
simplify = FALSE) |>
(\(x) Reduce('+', x))()
Gamma
WN
wi
dim(wi)
apply(wi, 2, tcrossprod(x), simplify = FALSE)
apply(wi, 2, tcrossprod, simplify = FALSE)
apply(wi, 2, tcrossprod, simplify = FALSE) |> length(1)
apply(wi, 2, tcrossprod, simplify = FALSE) |> length()
apply(wi, 2, tcrossprod, simplify = FALSE)[[1]] |> dim()
WN_bi <- apply(wi,
2,
tcrossprod,
simplify = FALSE) |>
(\(x) Reduce('+', x))()
WN_bi
dim(WN_bi)
# Compute cov
Gamma <- apply(wi * smoothed_curves,
2,
tcrossprod,
simplify = FALSE) |>
(\(x) Reduce('+', x) / WN_bi)()
Gamma
image(Gamma)
GA::persp3D(t_grid, t_grid, Gamma)
sigma
sigma_true
sigma = param_list$sigma
sigma
# Compute multiplicative term
norm_diag <- tcrossprod(sigma_hat) / WN_bi
# Compute multiplicative term
norm_diag <- tcrossprod(sigma) / WN_bi
norm_diag
dim(norm_diag)
wi
dim(wi)
dim(smoothed$weights[[1]])
dim(smoothed$weights[[2]])
smoothed$weights |> length()
ncol(wi)
# Compute diagonal sum
diag_sum <- purrr::imap(smoothed$weights,
~crossprod(x) * wi[, .y])
# Compute diagonal sum
diag_sum <- purrr::imap(smoothed$weights,
~crossprod(.x) * wi[, .y])
diag_sum
# Compute diagonal sum
diag_sum <- purrr::imap(smoothed$weights,
~crossprod(.x) * wi[, .y]) |>
(\(x) Reduce('+', x))()
diag_sum
dim(diag_sum)
dim(norm_diag)
cov_FPCA <- function(data, h, h_power, t_smooth, center = TRUE, sigma,
diag_cor) {
# Smooth curves at optimal bandwidth
smoothed <- smooth_curves(data = data, grid = t_smooth, bandwidth = h)
# Compute wi(t)
wi <- curves_select(curves = data,
x = t_smooth,
h = h)
WN <- rowSums(wi)
WN_bi <- apply(wi,
2,
tcrossprod,
simplify = FALSE) |>
(\(x) Reduce('+', x))()
# Center curves
if(center) {
mu <- purrr::imap(smoothed$smoothed_curves,
~.x * wi[, .y]) |>
(\(x) Reduce('+', x) / WN)()
smoothed_curves <- sapply(smoothed$smoothed_curves,
function(x) x - mu)
}
# Compute cov
Gamma <- apply(wi * smoothed_curves,
2,
tcrossprod,
simplify = FALSE) |>
(\(x) Reduce('+', x) / WN_bi)()
# Compute diagonal band correction
if(diag_cor) {
# Compute multiplicative term
norm_diag <- tcrossprod(sigma) / WN_bi
# Compute diagonal sum
diag_sum <- purrr::imap(smoothed$weights,
~crossprod(.x) * wi[, .y]) |>
(\(x) Reduce('+', x))()
# Correct diagonal band
Gamma - norm_diag * diag_sum
} else {
Gamma
}
}
rm(list=setdiff(ls(), c("data", "bw_adaptive", "param_list", "grid_smooth")))
cov_FPCA(data, bw_adaptive$bw_val[1], 0.9, seq(0, 1, l = 101), center = FALSE, sigma = param_list$sigma, TRUE)
cov_FPCA(data, bw_adaptive$bw_val[1], 0.9, seq(0, 1, l = 101), center = FALSE, sigma = param_list$sigma, TRUE) |> image()
cov_FPCA(data, bw_adaptive$bw_val[2], 0.9, seq(0, 1, l = 101), center = FALSE, sigma = param_list$sigma, TRUE)
cov_FPCA(data, bw_adaptive$bw_val[2], 0.9, seq(0, 1, l = 101), center = FALSE, sigma = param_list$sigma, TRUE)  |> image()
cov_FPCA(data, bw_adaptive$bw_val[2] / log(1 / bw_adaptive$bw_val[2]), 0.9, seq(0, 1, l = 101), center = FALSE, sigma = param_list$sigma, TRUE)  |> image()
bw_adaptive$bw_val[2] / log(1 / bw_adaptive$bw_val[2]
()
bw_adaptive$bw_val[2] / log(1 / bw_adaptive$bw_val[2])
bw_adaptive$bw_val[2] / log(1 / bw_adaptive$bw_val[2])
h_power = 0.9
grid_smooth
grid_smooth = seq(0, 1, l = 101)
center = FALSE
diag_cor = TRUE
# Get covariance of relevant bandwidths and eigen-elements
eigen_val <- purrr::map(bw_adaptive$bw_val, ~cov_FPCA(data = data,
h = .x,
h_power = h_power,
t_smooth = grid_smooth,
center = center,
diag_cor = diag_cor)) |>
purrr::map(~normalise_eigen(.x, nelements = nelements)$values)
nelements = 10
# Get covariance of relevant bandwidths and eigen-elements
eigen_val <- purrr::map(bw_adaptive$bw_val, ~cov_FPCA(data = data,
h = .x,
h_power = h_power,
t_smooth = grid_smooth,
center = center,
diag_cor = diag_cor)) |>
purrr::map(~normalise_eigen(.x, nelements = nelements)$values)
eigen_val
val_adapt <- purrr::map_dbl(seq_len(length(eigen_val)), ~eigen_val[[.x]][.x])
val_adapt
eigen_fun <- purrr::map(bw_adaptive$bw_fun, ~cov_FPCA(data = data,
h = .x,
h_power = h_power,
t_smooth = grid_smooth,
center = center,
diag_cor = diag_cor)) |>
purrr::map(~normalise_eigen(.x, nelements = nelements)$vectors)
eigen_fun
dim(eigen_fun)
fun_adapt <- sapply(seq_len(length(eigen_fun)),
function(j) eigen_fun[[j]][, j])
plot(fun_adapt[, 1])
plot(fun_adapt[, 1], type = "l")
plot(fun_adapt[, 2], type = "l")
plot(fun_adapt[, 3], type = "l")
plot(fun_adapt[, 4], type = "l")
plot(fun_adapt[, 5], type = "l")
getwd()
devtools::document()
[26/04 16:19] LE TRIONNAIRE Emmanuel
unlink("/home/me/src/Rlibs/00LOCK-FDAdapt", recursive = TRUE)
install.packages("pacman")
?pacman::p_unlock
pacman::p_unlock(lib.loc = ~/R/x86_64-pc-linux-gnu-library/4.2/00LOCK-FDAdapt)
getwd()
setwd("~/R/x86_64-pc-linux-gnu-library/4.2/00LOCK-FDAdapt")
getwd()
pacman::p_unlock()
getwd()
getwd()
setwd("~/R/x86_64-pc-linux-gnu-library/4.2")
getwd()
pacman::p_unlock()
setwd("~/FDAdapt")
getwd()
